rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    // ===== USERS =====
    match /Users/{userId} {
      allow read: if true;
      allow write: if request.auth != null && request.auth.uid == userId;
      
      // Permitir que owners de organizações atualizem organizationTag de usuários
      allow update: if request.auth != null && 
        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['organizationTag', 'updatedAt']);
    }
    
    // ===== POSTS =====
    match /Posts/{postId} {
      allow read: if true;
      allow create: if request.auth != null;
      allow update: if request.auth != null && 
        (request.auth.uid == resource.data.authorId || 
         request.resource.data.diff(resource.data).affectedKeys().hasOnly(['reactions', 'comments', 'updatedAt']));
      allow delete: if request.auth != null && request.auth.uid == resource.data.authorId;
    }
    
    // ===== ORGANIZATIONS =====
    match /organizations/{orgId} {
      // Permitir leitura de organizações públicas para todos (incluindo não autenticados)
      // Permitir leitura de organizações privadas apenas para membros/owner autenticados
      // Permitir leitura para usuários autenticados (necessário para validação de tags)
      allow read: if resource.data.visibility == 'public' || 
        (request.auth != null && 
         (request.auth.uid == resource.data.ownerId || 
          exists(/databases/$(database)/documents/organizations/$(orgId)/memberships/$(request.auth.uid)))) ||
        request.auth != null;
      
      // Permitir escrita completa para owner e membros
      allow write: if request.auth != null && 
        (request.auth.uid == resource.data.ownerId || 
         exists(/databases/$(database)/documents/organizations/$(orgId)/memberships/$(request.auth.uid)));
      
      // Permitir apenas atualização de pendingRequests para usuários autenticados em organizações públicas
      allow update: if request.auth != null && 
        resource.data.visibility == 'public' &&
        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['pendingRequests']) &&
        request.resource.data.pendingRequests.toSet().difference(resource.data.pendingRequests.toSet()).hasOnly([request.auth.uid]);
    }
    
    // ===== MEMBERSHIPS (Coleção Global) =====
    match /memberships/{membershipId} {
      allow read: if request.auth != null && 
        (request.auth.uid == resource.data.userId || 
         exists(/databases/$(database)/documents/organizations/$(resource.data.organizationId)/memberships/$(request.auth.uid)));
      
      // Permitir criação de membership próprio para usuários autenticados
      allow create: if request.auth != null && 
        request.auth.uid == request.resource.data.userId;
      
      // Permitir atualização/exclusão para o próprio usuário, owner ou membros existentes
      allow update, delete: if request.auth != null && 
        (request.auth.uid == resource.data.userId || 
         request.auth.uid == resource.data.ownerId ||
         exists(/databases/$(database)/documents/organizations/$(resource.data.organizationId)/memberships/$(request.auth.uid)));
    }
    
    // ===== MEMBERSHIPS (Subcoleção) =====
    match /organizations/{orgId}/memberships/{userId} {
      allow read: if request.auth != null && 
        (request.auth.uid == userId || 
         exists(/databases/$(database)/documents/organizations/$(orgId)/memberships/$(request.auth.uid)) ||
         get(/databases/$(database)/documents/organizations/$(orgId)).data.visibility == 'public');
      
      // Permitir criação de membership próprio com status "pending" em organizações públicas
      allow create: if request.auth != null && 
        request.auth.uid == userId &&
        request.auth.uid == request.resource.data.userId &&
        request.resource.data.status == 'pending' &&
        get(/databases/$(database)/documents/organizations/$(orgId)).data.visibility == 'public';
      
      // Permitir atualização/exclusão para owner e membros existentes
      allow update, delete: if request.auth != null && 
        (request.auth.uid == resource.data.ownerId || 
         exists(/databases/$(database)/documents/organizations/$(orgId)/memberships/$(request.auth.uid)));
    }
    
    // ===== EVENTS =====
    match /events/{eventId} {
      allow read: if true;
      allow create: if request.auth != null && 
        exists(/databases/$(database)/documents/organizations/$(request.resource.data.hostOrgId)/memberships/$(request.auth.uid));
      allow update: if request.auth != null && 
        exists(/databases/$(database)/documents/organizations/$(resource.data.hostOrgId)/memberships/$(request.auth.uid));
      allow delete: if request.auth != null && 
        request.auth.uid == resource.data.createdBy;
    }
    
    // ===== EVENT REGISTRATIONS =====
    match /eventRegistrations/{registrationId} {
      // Membros podem ver registrations da própria organização
      allow read: if request.auth != null && 
        exists(/databases/$(database)/documents/organizations/$(resource.data.orgId)/memberships/$(request.auth.uid));
      
      // Membros de uma organização podem ver TODAS as registrations dos eventos hospedados por sua organização
      // (permite ver todas as registrations de outros times nos eventos que sua org hospeda)
      allow read: if request.auth != null && 
        resource.data.eventId != null &&
        exists(/databases/$(database)/documents/events/$(resource.data.eventId)) &&
        get(/databases/$(database)/documents/events/$(resource.data.eventId)).data.hostOrgId != null &&
        exists(/databases/$(database)/documents/organizations/$(get(/databases/$(database)/documents/events/$(resource.data.eventId)).data.hostOrgId)/memberships/$(request.auth.uid));
      
      // Membros podem criar registrations da própria organização
      allow create: if request.auth != null && 
        exists(/databases/$(database)/documents/organizations/$(request.resource.data.orgId)/memberships/$(request.auth.uid));
      
      // Membros podem editar registrations da própria organização
      allow update, delete: if request.auth != null && 
        exists(/databases/$(database)/documents/organizations/$(resource.data.orgId)/memberships/$(request.auth.uid));
    }
    
    // ===== SEASONS =====
    match /seasons/{seasonId} {
      allow read: if true;
      allow write: if request.auth != null;
    }
    
    // ===== USER SEASON SCORES =====
    match /userSeasonScores/{scoreId} {
      allow read: if true;
      allow write: if request.auth != null && request.auth.uid == resource.data.userId;
    }
    
    // ===== DAILY INTERACTIONS =====
    match /dailyInteractions/{interactionId} {
      allow read: if request.auth != null && request.auth.uid == resource.data.userId;
      allow write: if request.auth != null && request.auth.uid == resource.data.userId;
    }
    
    // ===== EXTERNAL EVENT PARTICIPATIONS =====
    match /externalEventParticipations/{participationId} {
      allow read: if request.auth != null && request.auth.uid == resource.data.userId;
      allow write: if request.auth != null && request.auth.uid == resource.data.userId;
    }
    
    // ===== SCORE HISTORY =====
    match /scoreHistory/{historyId} {
      allow read: if true;
      allow write: if request.auth != null;
    }
    
    // ===== LOG MERCADO (ATIVIDADES RECENTES) =====
    match /logMercado/{logId} {
      allow read: if true; // Leitura pública para mostrar atividades
      allow write: if request.auth != null; // Escrita apenas para usuários autenticados
    }
    
    // ===== ORGANIZATION INVITES =====
    match /organizationInvites/{inviteId} {
      // Permitir leitura apenas para membros da organização ou o convidado
      allow read: if request.auth != null && 
        (request.auth.email == resource.data.inviteeEmail || 
         exists(/databases/$(database)/documents/organizations/$(resource.data.organizationId)/memberships/$(request.auth.uid)));
      
      // Permitir criação e exclusão apenas para membros da organização
      allow create, delete: if request.auth != null && 
        exists(/databases/$(database)/documents/organizations/$(resource.data.organizationId)/memberships/$(request.auth.uid));
      
      // Permitir atualização apenas para o convidado (aceitar/recusar) ou membros da organização
      allow update: if request.auth != null && 
        (request.auth.email == resource.data.inviteeEmail || 
         exists(/databases/$(database)/documents/organizations/$(resource.data.organizationId)/memberships/$(request.auth.uid)));
    }
    
    // ===== CHATS =====
    match /Chats/{chatId} {
      // Permitir leitura e escrita apenas para os participantes do chat
      // O chatId é formado pelos UIDs dos usuários ordenados: "uid1_uid2"
      allow read, write: if request.auth != null && (
        // Autoriza pelo padrão do ID do documento
        (chatId.split('_')[0] == request.auth.uid || chatId.split('_')[1] == request.auth.uid) ||
        // Autoriza se o usuário estiver listado em participants (para compatibilidade com chats antigos)
        (resource.data.participants != null && request.auth.uid in resource.data.participants)
      );

      // Subcoleção de mensagens (case-sensitive: Messages)
      match /Messages/{messageId} {
        allow read, write: if request.auth != null && 
          (chatId.split('_')[0] == request.auth.uid || chatId.split('_')[1] == request.auth.uid);
      }
      
      // Subcoleção de mensagens (case-sensitive: messages) - para compatibilidade
      match /messages/{messageId} {
        allow read, write: if request.auth != null && 
          (chatId.split('_')[0] == request.auth.uid || chatId.split('_')[1] == request.auth.uid);
      }
      
      // Subcoleção de status de digitação
      match /Typing/{userId} {
        allow read: if request.auth != null && 
          (chatId.split('_')[0] == request.auth.uid || chatId.split('_')[1] == request.auth.uid);
        allow write: if request.auth != null && 
          request.auth.uid == userId &&
          (chatId.split('_')[0] == request.auth.uid || chatId.split('_')[1] == request.auth.uid);
      }
    }
  }
}